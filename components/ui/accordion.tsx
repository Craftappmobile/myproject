import React, { createContext, useContext, useState } from "react"; import { Pressable, View } from "react-native"; import Animated, {   useAnimatedStyle,   useSharedValue,   withTiming, } from "react-native-reanimated"; import { ChevronDown } from "lucide-react-native"; import { cn } from "@/lib/utils";  type AccordionContextValue = {   value: string;   onValueChange: (value: string) => void;   type: "single" | "multiple";   collapsible: boolean; };  const AccordionContext = createContext<AccordionContextValue | null>(null);  function useAccordion() {   const context = useContext(AccordionContext);   if (!context) {     throw new Error("useAccordion must be used within an Accordion");   }   return context; }  type AccordionItemContextValue = {   value: string;   isOpen: boolean;   toggle: () => void; };  const AccordionItemContext = createContext<AccordionItemContextValue | null>(null);  function useAccordionItem() {   const context = useContext(AccordionItemContext);   if (!context) {     throw new Error("useAccordionItem must be used within an AccordionItem");   }   return context; }  type AccordionProps = {   type?: "single" | "multiple";   collapsible?: boolean;   value?: string;   onValueChange?: (value: string) => void;   className?: string;   children: React.ReactNode; };  function Accordion({   type = "single",   collapsible = false,   value,   onValueChange,   className,   children, }: AccordionProps) {   const [internalValue, setInternalValue] = useState<string>(value || "");    const handleValueChange = (newValue: string) => {     if (onValueChange) {       onValueChange(newValue);     } else {       setInternalValue(newValue);     }   };    return (     <AccordionContext.Provider       value={{         value: value !== undefined ? value : internalValue,         onValueChange: handleValueChange,         type,         collapsible,       }}     >       <View className={cn("", className)}>{children}</View>     </AccordionContext.Provider>   ); }  type AccordionItemProps = {   value: string;   className?: string;   children: React.ReactNode; };  function AccordionItem({ value, className, children }: AccordionItemProps) {   const { value: selectedValue, onValueChange, type, collapsible } = useAccordion();      const isOpen = type === "single"      ? selectedValue === value      : (selectedValue as string[])?.includes(value);    const toggle = () => {     if (type === "single") {       if (isOpen && collapsible) {         onValueChange("");       } else {         onValueChange(value);       }     } else {       // Multiple logic would go here     }   };    return (     <AccordionItemContext.Provider value={{ value, isOpen, toggle }}>       <View className={cn("border border-border rounded-md overflow-hidden", className)}>         {children}       </View>     </AccordionItemContext.Provider>   ); }  type AccordionTriggerProps = {   children: React.ReactNode;   className?: string; };  function AccordionTrigger({ children, className }: AccordionTriggerProps) {   const { isOpen, toggle } = useAccordionItem();   const rotation = useSharedValue(0);    rotation.value = withTiming(isOpen ? 180 : 0);    const animatedStyle = useAnimatedStyle(() => {     return {       transform: [{ rotate: `${rotation.value}deg` }],     };   });    return (     <Pressable       onPress={toggle}       className={cn("flex-row items-center justify-between p-4", className)}     >       {children}       <Animated.View style={animatedStyle}>         <ChevronDown size={20} color="#888" />       </Animated.View>     </Pressable>   ); }  type AccordionContentProps = {   children: React.ReactNode;   className?: string; };  function AccordionContent({ children, className }: AccordionContentProps) {   const { isOpen } = useAccordionItem();   const height = useSharedValue(0);    const animatedStyle = useAnimatedStyle(() => {     return {       height: isOpen ? "auto" : 0,       opacity: withTiming(isOpen ? 1 : 0),       overflow: "hidden",     };   });    if (!isOpen) return null;    return (     <Animated.View style={animatedStyle} className={cn("px-4", className)}>       {children}     </Animated.View>   ); }  Accordion.Item = AccordionItem; Accordion.Trigger = AccordionTrigger; Accordion.Content = AccordionContent;  export { Accordion };
